<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Afei_Yolo の Blog</title>
  
  
  <link href="https://afei-yolo.github.io/atom.xml" rel="self"/>
  
  <link href="https://afei-yolo.github.io/"/>
  <updated>2023-02-26T10:20:45.462Z</updated>
  <id>https://afei-yolo.github.io/</id>
  
  <author>
    <name>Afei_Yolo</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>git使用</title>
    <link href="https://afei-yolo.github.io/2023/02/26/Git%E4%BD%BF%E7%94%A8/"/>
    <id>https://afei-yolo.github.io/2023/02/26/Git%E4%BD%BF%E7%94%A8/</id>
    <published>2023-02-26T10:20:01.359Z</published>
    <updated>2023-02-26T10:20:45.462Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>本篇文章内容根据[廖雪峰的官方网站](<a href="https://www.liaoxuefeng.com/wiki/896043488029600">Git教程 - 廖雪峰的官方网站 (liaoxuefeng.com)</a>)编写，若有侵权，请联系我。</p><h1 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h1><h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h2><p>Git是目前世界上最先进的分布式版本控制系统（没有之一）。<br>Git 作用：版本控制（将项目的各个版本，即同一个项目修改和没修改过的版本保存在git的版本库中，便于用户管理各个版本，即历史记录）<br>分布式版本控制系统根本没有“中央服务器”，每个人的电脑上都是一个完整的版本库，这样，你工作的时候，就不需要联网了，因为版本库就在你自己的电脑上。既然每个人电脑上都有一个完整的版本库，那多个人如何协作呢？比方说你在自己电脑上改了文件A，你的同事也在他的电脑上改了文件A，这时，你们俩之间只需把各自的修改推送给对方，就可以互相看到对方的修改了。</p><h2 id="2-Git使用"><a href="#2-Git使用" class="headerlink" title="2. Git使用"></a>2. Git使用</h2><h3 id="2-1-git安装后设置"><a href="#2-1-git安装后设置" class="headerlink" title="2.1 git安装后设置"></a>2.1 git安装后设置</h3><p>因为Git是分布式版本控制系统，所以，首先设置的便是你的名字和Email地址。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name &quot;Your Name&quot;</span><br><span class="line">git config --global user.email &quot;email@example.com&quot;</span><br></pre></td></tr></table></figure><p>&#x3D;&#x3D;注意&#x3D;&#x3D;：<code>git config</code>命令的<code>--global</code>参数，用了这个参数，表示你这台机器上所有的Git仓库都会使用这个配置，当然也可以对某个仓库指定不同的用户名和Email地址。</p><h3 id="2-2-创建版本库"><a href="#2-2-创建版本库" class="headerlink" title="2.2 创建版本库"></a>2.2 创建版本库</h3><p>什么是版本库呢？版本库又名仓库，英文名<strong>repository</strong>，你可以简单理解成一个目录，这个目录里面的所有文件都可以被Git管理起来，每个文件的修改、删除，Git都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻可以“还原”。</p><p>&#x3D;&#x3D;创建一个版本库&#x3D;&#x3D;：首先，选择一个合适的文件夹，然后，进入文件夹右键选择<code>git bash here</code>打开git面板输入<code>git init</code>初始化命令把这个目录变成Git可以管理的仓库。也可以在<code>cmd</code>中切换到该文件夹输入<code>git init</code>（前提是git加入环境变量）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git init</span></span><br><span class="line">Initialized empty Git repository in E:/Git Repositories/.git/</span><br></pre></td></tr></table></figure><p>（这里我将&#x3D;&#x3D;Git Repositories&#x3D;&#x3D;文件目录变成变成Git可以管理的仓库）</p><p>&#x3D;&#x3D;注意&#x3D;&#x3D;：所有的版本控制系统，其实只能跟踪文本文件的改动，比如&#96;&#96;TXT<code>文件，网页，所有的程序代码等等，Git也不例外。版本控制系统可以告诉你每次的改动，比如在第5行加了一个单词“Linux”，在第8行删了一个单词“Windows”。而图片、视频这些二进制文件，虽然也能由版本控制系统管理，但没法跟踪文件的变化，只能把二进制文件每次改动串起来，也就是只知道图片从</code>100KB<code>改成了</code>120KB&#96;，但到底改了啥，版本控制系统不知道，也没法知道。</p><p>不幸的是，Microsoft的Word格式是二进制格式，因此，版本控制系统是没法跟踪Word文件的改动的，前面我们举的例子只是为了演示，如果要真正使用版本控制系统，就要以纯文本方式编写文件。</p><p>因为文本是有编码的，比如中文有常用的<code>GBK</code>编码，日文有<code>Shift_JIS</code>编码，如果没有历史遗留问题，强烈建议使用标准的<code>UTF-8</code>编码，所有语言使用同一种编码，既没有冲突，又被所有平台所支持。</p><h3 id="2-3-利用git进行基本操作"><a href="#2-3-利用git进行基本操作" class="headerlink" title="2.3 利用git进行基本操作"></a>2.3 利用git进行基本操作</h3><p>想要利用git的文件必须放在git版本库的父目录。例如：</p><p>在&#x3D;&#x3D;Git Repositories&#x3D;&#x3D;文件目录创建一个&#96;&#96;test.txt&#96;文件,文件内容为</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Git is a version control system.</span><br><span class="line">Git is free software.</span><br></pre></td></tr></table></figure><p>&#x3D;&#x3D;注意&#x3D;&#x3D;：一定要放到&#x3D;&#x3D;Git Repositories&#x3D;&#x3D;目录下（子目录也行），因为这是一个Git仓库，放到其他地方Git再厉害也找不到这个文件。</p><p>把一个文件放到Git版本仓库只需要两步。</p><p>第一步，用命令<code>git add</code>告诉Git，把文件添加到暂存库：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git add test.txt</span></span><br></pre></td></tr></table></figure><p>执行上面的命令之后是没有任何显示的。</p><p>第二步，用命令<code>git commit</code>告诉Git，把文件提交到版本仓库：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git commit -m <span class="string">&quot;wrote a test file&quot;</span></span></span><br><span class="line">[master (root-commit) d0b1fb8] wrote a test file</span><br><span class="line"> 1 file changed, 2 insertions(+)</span><br><span class="line"> create mode 100644 test.txt</span><br></pre></td></tr></table></figure><p>简单解释一下<code>git commit</code>命令，<code>-m</code>后面输入的是本次提交的说明，可以输入任意内容，当然最好是有意义的，这样你就能从历史记录里方便地找到改动记录。</p><p><code>git commit</code>命令执行成功后会告诉你，<code>1 file changed</code>：1个文件被改动（我们新添加的<code>readme.txt</code>文件）；<code>2 insertions</code>：插入了两行内容（<code>readme.txt</code>有两行内容）。</p><p>为什么Git添加文件需要<code>add</code>，<code>commit</code>一共两步呢？因为<code>commit</code>可以一次提交很多文件，所以你可以多次<code>add</code>不同的文件，比如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git add file1.txt</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git add file2.txt file3.txt</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git commit -m <span class="string">&quot;add 3 files.&quot;</span></span></span><br></pre></td></tr></table></figure><h2 id="3-git版本管理"><a href="#3-git版本管理" class="headerlink" title="3. git版本管理"></a>3. git版本管理</h2><h3 id="3-1-初识版本控制"><a href="#3-1-初识版本控制" class="headerlink" title="3.1 初识版本控制"></a>3.1 初识版本控制</h3><p>现在我们已经成功地添加并提交了一个<code>test.txt</code>文件，接着，我们继续修改<code>text.txt</code>文件，改成如下内容：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Git is a distributed version control system.</span><br><span class="line">Git is free software.</span><br></pre></td></tr></table></figure><p>现在，运行<code>git status</code>命令看看结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git status</span></span><br><span class="line">On branch master</span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">  (use &quot;git restore &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line">        modified:   test.txt</span><br><span class="line"></span><br><span class="line">no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)</span><br></pre></td></tr></table></figure><p><code>git status</code>命令可以让我们时刻掌握仓库当前的状态，上面的命令输出告诉我们，<code>readme.txt</code>被修改过了，但还没有准备提交的修改。</p><p>虽然Git告诉我们<code>readme.txt</code>被修改了，但如果能看看具体修改了什么内容，自然是很好的。所以，需要用<code>git diff</code>这个命令看看：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git diff test.txt</span></span><br><span class="line">diff --git a/test.txt b/test.txt</span><br><span class="line">index 9f7547c..b18bfcc 100644</span><br><span class="line">--- a/test.txt</span><br><span class="line">+++ b/test.txt</span><br><span class="line">@@ -1,2 +1,2 @@</span><br><span class="line">-Git is a version control system.</span><br><span class="line">+Git is a distributed version control system.^M</span><br><span class="line"> Git is free software.</span><br><span class="line">\ No newline at end of file</span><br></pre></td></tr></table></figure><p><code>git diff</code>顾名思义就是查看difference，显示的格式正是Unix通用的<code>diff</code>格式，可以从上面的命令输出看到，我们在第一行添加了一个<code>distributed</code>单词。</p><p>知道了对<code>readme.txt</code>作了什么修改后，再把它提交到仓库就放心多了，提交修改和提交新文件是一样的两步，第一步是<code>git add</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git add test.txt</span></span><br></pre></td></tr></table></figure><p>同样没有任何输出。在执行第二步<code>git commit</code>之前，我们再运行<code>git status</code>看看当前仓库的状态：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git status</span></span><br><span class="line">On branch master</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git restore --staged &lt;file&gt;...&quot; to unstage)</span><br><span class="line">        modified:   test.txt</span><br></pre></td></tr></table></figure><p><code>git status</code>告诉我们，将要被提交的修改包括<code>readme.txt</code>，下一步，就可以放心地提交了：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git commit -m <span class="string">&quot;add distributed&quot;</span></span></span><br><span class="line">[master 4522e3b] add distributed</span><br><span class="line"> 1 file changed, 1 insertion(+), 1 deletion(-)</span><br></pre></td></tr></table></figure><p>提交后，我们再用<code>git status</code>命令看看仓库的当前状态：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git status</span></span><br><span class="line">On branch master</span><br><span class="line">nothing to commit, working tree clean</span><br></pre></td></tr></table></figure><h3 id="3-2-版本回退"><a href="#3-2-版本回退" class="headerlink" title="3.2 版本回退"></a>3.2 版本回退</h3><p>现在，我们回顾一下<code>test.txt</code>文件一共有几个版本被提交到Git仓库里了：</p><p>版本1：<code>wrote a test file</code></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Git is a version control system.</span><br><span class="line">Git is free software.</span><br></pre></td></tr></table></figure><p>版本2：<code>add distributed</code></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Git is a distributed version control system.</span><br><span class="line">Git is free software.</span><br></pre></td></tr></table></figure><p>在Git中，我们用<code>git log</code>命令查看历史记录：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">log</span></span></span><br><span class="line">commit 4522e3bb191906be7cd9fbbe3ed125e901b5116f (HEAD -&gt; master)</span><br><span class="line">Author: Afei-Yolo &lt;15536180253@163.com&gt;</span><br><span class="line">Date:   Tue Feb 21 19:28:11 2023 +0800</span><br><span class="line"></span><br><span class="line">    add distributed</span><br><span class="line"></span><br><span class="line">commit d0b1fb81d6c2e100cf81647584dd408c8615ea03</span><br><span class="line">Author: Afei-Yolo &lt;15536180253@163.com&gt;</span><br><span class="line">Date:   Tue Feb 21 19:17:52 2023 +0800</span><br><span class="line"></span><br><span class="line">    wrote a test file</span><br></pre></td></tr></table></figure><p>如果嫌输出信息太多，看得眼花缭乱的，可以试试加上<code>--pretty=oneline</code>参数：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">log</span> --pretty=oneline</span></span><br><span class="line">4522e3bb191906be7cd9fbbe3ed125e901b5116f (HEAD -&gt; master) add distributed</span><br><span class="line">d0b1fb81d6c2e100cf81647584dd408c8615ea03 wrote a test file</span><br></pre></td></tr></table></figure><p>&#x3D;&#x3D;注意&#x3D;&#x3D;：你看到的一大串类似<code>1094adb...</code>的是<code>commit id</code>（版本号）</p><p><a name="master">(HEAD -&gt; master)</a>: 解释请点链接:innocent:</p><p>现在我们准备把<code>test.txt</code>回退到上一个版本，也就是<code>wrote a test file</code>的那个版本</p><p>首先，Git必须知道当前版本是哪个版本，在Git中，用<code>HEAD</code>表示当前版本，上一个版本就是<code>HEAD^</code>，上上一个版本就是<code>HEAD^^</code>，当然往上100个版本写100个<code>^</code>比较容易数不过来，所以写成<code>HEAD~100</code>。</p><p>现在，我们要把当前版本<code>add distributed</code>回退到上一个版本<code>wrote a test file</code>，就可以使用<code>git reset</code>命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git reset --hard HEAD^</span></span><br><span class="line">HEAD is now at d0b1fb8 wrote a test file</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> test.txt</span></span><br><span class="line">Git is a version control system.</span><br><span class="line">Git is free software.</span><br></pre></td></tr></table></figure><p>果然被还原了。</p><p>让我们用<code>git log</code>再看看现在版本库的状态：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Author: Afei-Yolo &lt;15536180253@163.com&gt;</span><br><span class="line">Date:   Tue Feb 21 19:17:52 2023 +0800</span><br><span class="line"></span><br><span class="line">    wrote a test file</span><br></pre></td></tr></table></figure><p>最新的那个版本<code>add distributed</code>已经看不到了！</p><p>但如果我们想要回到最新的版本，只要找到那个<code>add distributed</code>的<code>commit id</code>是<code>4522e3...</code>，于是就可以指定回到未来的某个版本：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git reset --hard 4522e3</span></span><br><span class="line">HEAD is now at 4522e3b add distributed</span><br></pre></td></tr></table></figure><p>再小心翼翼地看看<code>test.txt</code>的内容：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> test.txt</span></span><br><span class="line">Git is a distributed version control system.</span><br><span class="line">Git is free software.</span><br></pre></td></tr></table></figure><p>Git的版本回退速度非常快，因为Git在内部有个指向当前版本的<code>HEAD</code>指针，当你回退版本的时候，Git仅仅是把HEAD从指向<code>add distributed</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">┌────┐</span><br><span class="line">│HEAD│</span><br><span class="line">└────┘</span><br><span class="line">   │</span><br><span class="line">   └──▶ ○ add distributed</span><br><span class="line">        │</span><br><span class="line">        ○ wrote a test file</span><br></pre></td></tr></table></figure><p>改为指向<code>wrote a test file</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">┌────┐</span><br><span class="line">│HEAD│</span><br><span class="line">└────┘</span><br><span class="line">   │</span><br><span class="line">   │    ○ append GPL</span><br><span class="line">   │    │</span><br><span class="line">   └──▶ ○ wrote a test file</span><br></pre></td></tr></table></figure><p>然后顺便把工作区的文件更新了。所以你让<code>HEAD</code>指向哪个版本号，你就把当前版本定位在哪。</p><p>现在，你回退到了某个版本，关掉了电脑，第二天早上就后悔了，但找不到新版本的<code>commit id</code>怎么办？</p><p>在Git中，总是有后悔药可以吃的。当你用<code>$ git reset --hard HEAD^</code>回退到<code>wrote a test file</code>版本时，再想恢复到<code>add distributed</code>，就必须找到<code>add distributed</code>的<code>commit id</code>。Git提供了一个命令<code>git reflog</code>用来记录你的每一次命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git reflog</span></span><br><span class="line">4522e3b (HEAD -&gt; master) HEAD@&#123;0&#125;: reset: moving to 4522e3</span><br><span class="line">d0b1fb8 HEAD@&#123;1&#125;: reset: moving to HEAD^</span><br><span class="line">4522e3b (HEAD -&gt; master) HEAD@&#123;2&#125;: commit: add distributed</span><br><span class="line">d0b1fb8 HEAD@&#123;3&#125;: commit (initial): wrote a test file</span><br></pre></td></tr></table></figure><p>终于舒了口气，你又可以乘坐时光机回到未来了。</p><h3 id="3-2-管理修改"><a href="#3-2-管理修改" class="headerlink" title="3.2 管理修改"></a>3.2 管理修改</h3><p>每次修改，如果不用<code>git add</code>到暂存区，那就不会加入到<code>commit</code>中</p><h3 id="3-3-撤销修改"><a href="#3-3-撤销修改" class="headerlink" title="3.3 撤销修改"></a>3.3 撤销修改</h3><p>场景1：当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令<code>git checkout --&lt;file&gt;</code>。（当然，如果你打开该文件的软件还有撤销功能的话，点它！！）</p><p>场景2：当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，即：你改了文件并用了<code>add</code>命令。想丢弃修改，分两步，第一步用命令<code>git reset HEAD &lt;file&gt;</code>，就回到了场景1，第二步按场景1操作。</p><p>场景3：已经提交了不合适的修改到版本库时，想要撤销本次提交，参考<a href="https://www.liaoxuefeng.com/wiki/896043488029600/897013573512192">版本回退</a>一节，不过前提是没有推送到远程库。</p><h3 id="3-4-删除文件"><a href="#3-4-删除文件" class="headerlink" title="3.4 删除文件"></a>3.4 删除文件</h3><p>命令rm用于删除文件，但工作区和版本库就不一致了，<code>git status</code>命令会立刻告诉你哪些文件被删除了，之后有两种情况：</p><ol><li><p>确实要从版本库中删除该文件，那就用命令<code>git rm</code>删掉，并且<code>git commit</code>，现在，文件就从版本库中被删除了。</p></li><li><p>删错了，可以用下列命令很轻松地把误删的文件恢复到最新版本：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git checkout -- test.txt</span></span><br></pre></td></tr></table></figure></li></ol><p><code>git checkout</code>其实是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以“一键还原”。</p><h2 id="4-远程仓库"><a href="#4-远程仓库" class="headerlink" title="4. 远程仓库"></a>4. 远程仓库</h2><h3 id="4-1-将本地git版本库推送到远程仓库（本例采用GitHub仓库）"><a href="#4-1-将本地git版本库推送到远程仓库（本例采用GitHub仓库）" class="headerlink" title="4.1 将本地git版本库推送到远程仓库（本例采用GitHub仓库）"></a>4.1 将本地git版本库推送到远程仓库（本例采用<code>GitHub</code>仓库）</h3><ul><li><p>在GitHub新建一个仓库</p></li><li><p>链接本地git版本库与GitHub仓库</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin git@github.com:michaelliao/learngit.git</span><br></pre></td></tr></table></figure><p><code>@github.com:michaelliao/learngit.git</code>：你的仓库地址，添加后，远程库的名字就是<code>origin</code></p></li><li><p>把本地库推送到GitHub仓库：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure><p>由于远程库是空的，我们第一次推送<code>master</code>分支时，加上了<code>-u</code>参数，Git不但会把本地的<code>master</code>分支内容推送的远程新的<code>master</code>分支，还会把本地的<code>master</code>分支和远程的<code>master</code>分支关联起来，在以后的推送或者拉取时就可以简化命令。</p></li></ul><h3 id="4-2-从远程仓库克隆"><a href="#4-2-从远程仓库克隆" class="headerlink" title="4.2 从远程仓库克隆"></a>4.2 从远程仓库克隆</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone git@github.com:michaelliao/gitskills.git</span><br></pre></td></tr></table></figure><p><code>@github.com:michaelliao/gitskills.git</code>：仓库地址</p><h2 id="5-分支管理"><a href="#5-分支管理" class="headerlink" title="5. 分支管理"></a>5. 分支管理</h2><h3 id="5-1-分支介绍"><a href="#5-1-分支介绍" class="headerlink" title="5.1 分支介绍"></a>5.1 分支介绍</h3><p>现在，我们假设有一个文件1，其修改为2，3，4，5，6；其<code>add</code>到暂存区的文件为对应的1(对于文件1)，2，3，4，5，6；提交到版本区的文件为1，2，3，4，5，6.(&#x3D;&#x3D;注意&#x3D;&#x3D;：提交到版本区之后，暂存区相应的文件会消失,🤔,也就是没了。这里标出来只是为了形象)；在提交了3之后，我们新建了<code>ber</code>分支，(注意现在<code>main</code>和<code>ber</code>都指向3，而<code>HADE</code>指向<code>main</code>),之后，我们在工作区将3改为了4，并<code>add</code>到暂存区为4，提交到版本区为4，此时<code>HADE</code>指向<code>main</code>,<code>main</code>指向4，而<code>ber</code>仍指向3，接着我们修改4为5，并<code>add</code>到暂存区为5，修改分支为<code>ber</code>，提交到版本区为5，此时<code>HADE</code>指向<code>ber</code>，<code>ber</code>指向5，最后我们修改5为6，并<code>add</code>到暂存区为6，提交到版本区为6，此时<code>HADE</code>指向<code>ber</code>，<code>ber</code>指向6。</p><p><img src="https://cdn.jsdelivr.net/gh/Afei-Yolo/Picgodemo/img/image-20230225211041682.png" alt="image-20230225211041682"></p><h3 id="5-2-分支操作"><a href="#5-2-分支操作" class="headerlink" title="5.2 分支操作"></a>5.2 分支操作</h3><ol><li><p>用<code>git checkout -b ber</code>新建分支</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git checkout -b ber</span></span><br><span class="line">Switched to a new branch &#x27;ber&#x27;</span><br></pre></td></tr></table></figure><p><code>git checkout</code>命令加上<code>-b</code>参数表示创建并切换，相当于以下两条命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git branch ber</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git checkout ber</span></span><br><span class="line">Switched to branch &#x27;ber&#x27;</span><br></pre></td></tr></table></figure><p>最新版本的Git提供了新的<code>git switch</code>命令来切换分支：</p><p>创建并切换到新的<code>ber</code>分支，可以使用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git switch -c ber</span><br></pre></td></tr></table></figure></li><li><p>用<code>git branch</code>命令查看当前分支：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git branch</span></span><br><span class="line">* ber</span><br><span class="line">  master</span><br></pre></td></tr></table></figure><p><code>git branch</code>命令会列出所有分支，当前分支前面会标一个<code>*</code>号。</p></li><li><p>切换分支</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git switch master</span></span><br></pre></td></tr></table></figure></li><li><p>删除分支：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git branch -d dev</span></span><br><span class="line">Deleted branch dev (was b17d20e).</span><br></pre></td></tr></table></figure></li></ol><h3 id="5-3-合并分支"><a href="#5-3-合并分支" class="headerlink" title="5.3 合并分支"></a>5.3 合并分支</h3><ol><li><p>某个分支的内容比另一个分支的内容新时：(此时<code>dev</code>内容较新)</p><p><img src="https://cdn.jsdelivr.net/gh/Afei-Yolo/Picgodemo/img/image-20230226090903647.png" alt="image-20230226090903647"><br><code>git merge</code>命令用于合并指定分支到当前分支:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git merge dev</span></span><br><span class="line">Updating d46f35e..b17d20e</span><br><span class="line">Fast-forward</span><br><span class="line"> readme.txt | 1 +</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br></pre></td></tr></table></figure><p>上面的<code>Fast-forward</code>信息，Git告诉我们，这次合并是“快进模式”，也就是直接把<code>master</code>指向<code>dev</code>的当前提交，所以合并速度非常快。</p></li><li><p>两个分支指向内容不一样，即：<br><img src="https://cdn.jsdelivr.net/gh/Afei-Yolo/Picgodemo/img/image-20230226091303296.png" alt="image-20230226091303296"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git merge feature1</span></span><br><span class="line">Auto-merging 1.txt</span><br><span class="line">CONFLICT (content): Merge conflict in 1.txt</span><br><span class="line">Automatic merge failed; fix conflicts and then commit the result.</span><br></pre></td></tr></table></figure><p>有冲突。用<code>git status</code>查看一下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git status</span></span><br><span class="line">On branch master</span><br><span class="line">You have unmerged paths.</span><br><span class="line">  (fix conflicts and run &quot;git commit&quot;)</span><br><span class="line">  (use &quot;git merge --abort&quot; to abort the merge)</span><br><span class="line"></span><br><span class="line">Unmerged paths:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to mark resolution)</span><br><span class="line">        both modified:   1.txt</span><br><span class="line"></span><br><span class="line">no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)</span><br></pre></td></tr></table></figure><p>用<code>cat</code>查看文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> 1.txt</span></span><br><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</span><br><span class="line">abcdefghijklmnopqr123456789！@#￥%……&amp;*</span><br><span class="line">=======</span><br><span class="line">abcdefghijklmnopqr123456789+++++++++++</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt;&gt;&gt;&gt;&gt; feature1</span></span><br></pre></td></tr></table></figure><p>我们修改内容提交到任意一个分支，情况就与1一样了。</p></li></ol><h3 id="5-4-分支管理策略"><a href="#5-4-分支管理策略" class="headerlink" title="5.4 分支管理策略"></a>5.4 分支管理策略</h3><p>`&#96;&#96;bash</p><p>​     A—B—C topic</p><p>   &#x2F;     \</p><p>  D—E———–H master</p><p>`&#96;&#96;</p><p>从E分叉出topic分支，topic分支上提交了A、B、C，但master上从E开始没有进行提交。</p><p>当我们处于master分支，想要将topic分支合并到master中时，就涉及到三个不同的选项–ff、–no-ff、–ff-only。也就是说这三个选项只在这种情况有效，这种情况为：master上从E开始都没有提交，并想要将topic分支合并到master中。这种情况称为“当合并的历史是当前历史的后代”。</p><p>节点的tag不存储在refs&#x2F;tags&#x2F;中时，默认使用–no-ff。其他情况默认使用–ff</p><p>–no-ff：创建新的提交H</p><p>`&#96;&#96;bash</p><p>​     A—B—C topic</p><p>   &#x2F;     \</p><p>  D—E———–H master</p><p>`&#96;&#96;</p><p>–ff：不创建新的提交H，将指针mater指向C，得到如下结果：</p><p>`&#96;&#96;bash</p><p>D—E—A—B—C master</p><p>`&#96;&#96;</p><p>–squash：将待合并分支的最后一个提交放到当前分支的工作区。如A、B、C对readme.txt进行了修改，那么–squash的作用就是将经过A、B、C的readme.txt文件复制到工作区中。然后我们就可以进行add和commit来生成一个提交。生成的这个提交，就相当于对A、B、C工作的总结。</p><p>如果复制到工作区的readme.txt文件与工作区中的readme.txt文件有冲突？？答：出现这种冲突时的处理办法就是将冲突内容全部展示在readme.txt中。</p><p>–squash只是为让提交的日志看起来简洁一些。</p><h2 id="6-标签管理"><a href="#6-标签管理" class="headerlink" title="6. 标签管理"></a>6. 标签管理</h2><h3 id="6-1-标签介绍"><a href="#6-1-标签介绍" class="headerlink" title="6.1 标签介绍"></a>6.1 标签介绍</h3><p>发布一个版本时，我们通常先在版本库中打一个标签（tag），这样，就唯一确定了打标签时刻的版本。将来无论什么时候，取某个标签的版本，就是把那个打标签的时刻的历史版本取出来。所以，标签也是版本库的一个快照。</p><p>Git的标签虽然是版本库的快照，但其实它就是指向某个commit的指针（跟分支很像对不对？但是分支可以移动，标签不能移动），所以，创建和删除标签都是瞬间完成的。</p><p>Git有commit，为什么还要引入tag？</p><p>“请把上周一的那个版本打包发布，commit号是6a5819e…”</p><p>“一串乱七八糟的数字不好找！”</p><p>如果换一个办法：</p><p>“请把上周一的那个版本打包发布，版本号是v1.2”</p><p>“好的，按照tag v1.2查找commit就行！”</p><p>所以，tag就是一个让人容易记住的有意义的名字，它跟某个commit绑在一起。</p><h3 id="6-2-标签操作"><a href="#6-2-标签操作" class="headerlink" title="6.2 标签操作"></a>6.2 标签操作</h3><ol><li><p>创建标签</p><p>找到打标签的分支以及版本，输入：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git tag v1.0 f52c633</span></span><br></pre></td></tr></table></figure><p><code>f52c633</code>:版本号</p><p>创建带有说明的标签，用<code>-a</code>指定标签名，<code>-m</code>指定说明文字：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git tag -a v0.1 -m <span class="string">&quot;version 0.1 released&quot;</span> 1094adb</span></span><br></pre></td></tr></table></figure></li><li><p>查看标签</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git tag</span></span><br><span class="line">v1.0</span><br></pre></td></tr></table></figure><p>查看标签详细信息：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git show v0.9</span></span><br></pre></td></tr></table></figure><p>&#x3D;&#x3D;注意&#x3D;&#x3D;：标签总是和某个commit挂钩。如果这个commit既出现在master分支，又出现在dev分支，那么在这两个分支上都可以看到这个标签。</p></li><li><p>删除标签</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git tag -d v0.1</span></span><br><span class="line">Deleted tag &#x27;v0.1&#x27; (was f15b0dd)</span><br></pre></td></tr></table></figure><p>创建的标签都只存储在本地，不会自动推送到远程,打错的标签可以在本地安全删除。</p><p>如果标签已经推送到远程，要删除远程标签就麻烦一点，先从本地删除：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git tag -d v0.9</span></span><br><span class="line">Deleted tag &#x27;v0.9&#x27; (was f52c633)</span><br></pre></td></tr></table></figure><p>然后，从远程删除。删除命令也是push，但是格式如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git push origin :refs/tags/v0.9</span></span><br><span class="line">To github.com:michaelliao/learngit.git</span><br><span class="line"> - [deleted]         v0.9</span><br></pre></td></tr></table></figure></li><li><p>推送标签</p><p>推送某个标签到远程，使用命令<code>git push origin &lt;tagname&gt;</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git push origin v1.0</span></span><br><span class="line">Total 0 (delta 0), reused 0 (delta 0)</span><br><span class="line">To github.com:michaelliao/learngit.git</span><br><span class="line"> * [new tag]         v1.0 -&gt; v1.0</span><br></pre></td></tr></table></figure><p>一次性推送全部尚未推送到远程的本地标签：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git push origin --tags</span></span><br><span class="line">Total 0 (delta 0), reused 0 (delta 0)</span><br><span class="line">To github.com:michaelliao/learngit.git</span><br><span class="line"> * [new tag]         v0.9 -&gt; v0.9</span><br></pre></td></tr></table></figure></li></ol><h2 id="7-忽略特殊文件"><a href="#7-忽略特殊文件" class="headerlink" title="7. 忽略特殊文件"></a>7. 忽略特殊文件</h2><p>在Git工作区的根目录下创建一个特殊的<code>.gitignore</code>文件，然后把要忽略的文件名填进去，Git就会自动忽略这些文件。</p><p>把指定文件排除在<code>.gitignore</code>规则外的写法就是<code>!</code>+文件名，所以，只需把例外文件添加进去即可。</p><p>忽略文件的原则是：</p><ol><li>忽略操作系统自动生成的文件，比如缩略图等；</li><li>忽略编译生成的中间文件、可执行文件等，也就是如果一个文件是通过另一个文件自动生成的，那自动生成的文件就没必要放进版本库，比如Java编译产生的<code>.class</code>文件；</li><li>忽略你自己的带有敏感信息的配置文件，比如存放口令的配置文件。</li></ol>]]></content>
    
    
    <summary type="html">git使用教程</summary>
    
    
    
    <category term="Git" scheme="https://afei-yolo.github.io/categories/Git/"/>
    
    
  </entry>
  
  <entry>
    <title>github+hexo部署博客</title>
    <link href="https://afei-yolo.github.io/2023/02/25/%E9%83%A8%E7%BD%B2%E5%8D%9A%E5%AE%A2/"/>
    <id>https://afei-yolo.github.io/2023/02/25/%E9%83%A8%E7%BD%B2%E5%8D%9A%E5%AE%A2/</id>
    <published>2023-02-24T16:00:00.000Z</published>
    <updated>2023-02-26T10:19:30.243Z</updated>
    
    <content type="html"><![CDATA[<h1 id="github-hexo部署博客"><a href="#github-hexo部署博客" class="headerlink" title="github+hexo部署博客"></a>github+hexo部署博客</h1><h2 id="1-部署前准备"><a href="#1-部署前准备" class="headerlink" title="1. 部署前准备"></a>1. 部署前准备</h2><h3 id="1-1-下载-git-Git-Downloading-Package-镜像下载"><a href="#1-1-下载-git-Git-Downloading-Package-镜像下载" class="headerlink" title="1.1 下载 git  Git - Downloading Package 镜像下载"></a>1.1 下载 git  <a href="https://link.zhihu.com/?target=https://git-scm.com/download/win">Git - Downloading Package</a> <a href="https://npm.taobao.org/mirrors/git-for-windows/">镜像下载</a></h3><h3 id="1-2-下载-node-js-Download-Node-js"><a href="#1-2-下载-node-js-Download-Node-js" class="headerlink" title="1.2 下载 node.js  Download | Node.js"></a>1.2 下载 node.js  <a href="https://link.zhihu.com/?target=https://nodejs.org/en/download/">Download | Node.js</a></h3><h3 id="1-3-GitHub新建仓库"><a href="#1-3-GitHub新建仓库" class="headerlink" title="1.3 GitHub新建仓库"></a>1.3 GitHub新建仓库</h3><p><img src="https://cdn.jsdelivr.net/gh/Afei-Yolo/Picgodemo/img/image-20230225111229485.png" alt="image-20230225111229485"></p><p><img src="https://cdn.jsdelivr.net/gh/Afei-Yolo/Picgodemo/img/image-20230225111549229.png" alt="image-20230225111549229"></p><h3 id="1-4-git与GitHub同步："><a href="#1-4-git与GitHub同步：" class="headerlink" title="1.4 git与GitHub同步："></a>1.4 git与GitHub同步：</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name &quot;你的GitHub用户名&quot;</span><br><span class="line">git config --global user.email &quot;你的GitHub注册邮箱&quot;</span><br></pre></td></tr></table></figure><p>生成ssh密匙文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;你的GitHub注册邮箱&quot;</span><br></pre></td></tr></table></figure><p>然后直接三个回车即可，默认不需要设置密码.<br>然后找到生成的.ssh的文件夹中的id_rsa.pub密钥，将内容全部复制.<br><img src="https://cdn.jsdelivr.net/gh/Afei-Yolo/Picgodemo/img/image-20230225111928594.png" alt="image-20230225111928594"></p><p>打开<a href="https://link.zhihu.com/?target=https://github.com/settings/keys">GitHub_Settings_keys</a> 页面，新建new SSH Key.</p><p><img src="https://cdn.jsdelivr.net/gh/Afei-Yolo/Picgodemo/img/image-20230225112228823.png" alt="image-20230225112228823"></p><p><img src="https://cdn.jsdelivr.net/gh/Afei-Yolo/Picgodemo/img/image-20230225112236016.png" alt="image-20230225112236016"></p><p><img src="https://cdn.jsdelivr.net/gh/Afei-Yolo/Picgodemo/img/image-20230225112247009.png" alt="image-20230225112247009"><br>在Git Bash中检测GitHub公钥设置是否成功，输入 <code>ssh git@github.com</code>.</p><p><img src="C:\Users\25442\AppData\Roaming\Typora\typora-user-images\image-20230225112751636.png" alt="image-20230225112751636"></p><h3 id="1-5-安装hexo"><a href="#1-5-安装hexo" class="headerlink" title="1.5 安装hexo"></a>1.5 安装hexo</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo-cli </span><br></pre></td></tr></table></figure><p>找到博客目录，进入右键<code>git bash here</code>,输入：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo init</span><br></pre></td></tr></table></figure><p>(这里的命令是作用在刚刚创建的Blog文件夹中)<br>到此，博客基本框架建立完毕。<br>查看本地服务器上的博客：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo g    ----生成静态网页</span><br><span class="line">hexo s    ----本地服务器开启</span><br></pre></td></tr></table></figure><h2 id="2-hexo与GitHub关联"><a href="#2-hexo与GitHub关联" class="headerlink" title="2. hexo与GitHub关联"></a>2. hexo与GitHub关联</h2><p>打开博客目录下的<code>_config.yml</code>配置文件，修改&#x2F;添加：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">type: git</span><br><span class="line">repo: https://github.com/(github用户名)/(github用户名).github.io.git</span><br><span class="line">branch: main</span><br></pre></td></tr></table></figure><h2 id="3-部署到github仓库"><a href="#3-部署到github仓库" class="headerlink" title="3 部署到github仓库"></a>3 部署到github仓库</h2><h3 id="3-1-安装git部署插件"><a href="#3-1-安装git部署插件" class="headerlink" title="3.1 安装git部署插件"></a>3.1 安装git部署插件</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><h3 id="3-2-部署"><a href="#3-2-部署" class="headerlink" title="3.2 部署"></a>3.2 部署</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo clean  -----清除缓存文件</span><br><span class="line">hexo d   ----- 生成静态文件并上传博客到GitHub仓库</span><br></pre></td></tr></table></figure><h3 id="3-3-查看博客"><a href="#3-3-查看博客" class="headerlink" title="3.3 查看博客"></a>3.3 查看博客</h3><p>网址：https:&#x2F;&#x2F;(GitHub用户名).github.io&#x2F;</p>]]></content>
    
    
    <summary type="html">个人博客部署</summary>
    
    
    
    <category term="github+hexo部署博客" scheme="https://afei-yolo.github.io/categories/github-hexo%E9%83%A8%E7%BD%B2%E5%8D%9A%E5%AE%A2/"/>
    
    
    <category term="Blog" scheme="https://afei-yolo.github.io/tags/Blog/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://afei-yolo.github.io/2023/02/22/hello-world/"/>
    <id>https://afei-yolo.github.io/2023/02/22/hello-world/</id>
    <published>2023-02-22T06:14:52.296Z</published>
    <updated>2023-02-25T07:19:23.621Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    <summary type="html">hexo-hello world</summary>
    
    
    
    
  </entry>
  
</feed>
